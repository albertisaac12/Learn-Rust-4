Debug mode is fast and unoptimized build , compiler includes additional metadata
Release mode takes longer to compile but optimizes runtime performance
final executable will be inside the target

`cargo check` checks for compiler violation // skips the creation of an executable

A compiler directive is when we add some meta data in the code which then directs the compiler to behave in a certain way.
We write the compiler directive just above the entity to which the compiler directive will be applied to.

Option<i32> and i32 are not the same

```txt

if let PATTERN = VALUE {
    // do something
}

the variable inside the pattern gets assigned with the value good if you want to use it for a single arm of match statement
```

What i understood from `let else` syntax:

Some variable x = Some other value { do stuff } else { do some other stuff }

Variable shadowing will occur in the same scope

constant values must be known at the compile time, need to explicitly specify the type.

precision: f32 6-9 digits , f64 15-17 digits

usize and isize : depends on the system architecture

string literals => value of these strings are known at the compile time. `&str`

`println!(" blah blah \" ");` `\` is a escape character.

`r" \m"` the `r` at the beginning tells rust to treat the entire string literal as a raw string.

method is a function that lives on that value.

`{:}` the `:` is a format specifier , the format specifier customizes the printed representation of the interpolated value

`vectors` are dynamic in size and are stored on the heap while `arrays` have fixed size and are stored in the stack

```plaintext
    A trait is like a contract that outlines certain rules, these rules are defined as methods
    when a type opts to honor a traits's requirements i.e the rules we say the type implements these traits
    Types can vary in their implementation but still implement the same trait

    In simple terms trait is an interface for a type.
```

`dbg!()` => file path + line + number of spaces in the line + the entire result in detail

The range type is not available in the top level of file and is nested in a `module`

## What is ownership ?

Ownership is a set of rules compiler checks for to ensure program will be free of memory errors

## NOTE : the string literal &str is not stored either on stack or on heap rather it is embedded in the binary executable generated by the compiler

Associated functions are called on types and methods are called on instance of the type. Generally Associated functions do not have the `&self` passed as an argument.

When a `String` is created on heap correspondingly on the stack there will be an entry that will created which holds the reference to the String on heap,its length and capacity(amount of bytes available in the heap location).

`println!()` macro takes an immutable reference to argument passed.

`drop()` function can be called manually too.

rust has a feature called auto dereference

rust also implements the `Display` trait for references hence when you print a reference it will print the value and not the address.
