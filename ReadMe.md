Debug mode is fast and unoptimized build , compiler includes additional metadata
Release mode takes longer to compile but optimizes runtime performance
final executable will be inside the target

`cargo check` checks for compiler violation // skips the creation of an executable

A compiler directive is when we add some meta data in the code which then directs the compiler to behave in a certain way.
We write the compiler directive just above the entity to which the compiler directive will be applied to.

Option<i32> and i32 are not the same

```txt

if let PATTERN = VALUE {
    // do something
}

the variable inside the pattern gets assigned with the value good if you want to use it for a single arm of match statement
```

What i understood from `let else` syntax:

Some variable x = Some other value { do stuff } else { do some other stuff }

Variable shadowing will occur in the same scope

constant values must be known at the compile time, need to explicitly specify the type.

precision: f32 6-9 digits , f64 15-17 digits

usize and isize : depends on the system architecture

string literals => value of these strings are known at the compile time. `&str`

`println!(" blah blah \" ");` `\` is a escape character.

`r" \m"` the `r` at the beginning tells rust to treat the entire string literal as a raw string.

method is a function that lives on that value.

`{:}` the `:` is a format specifier , the format specifier customizes the printed representation of the interpolated value

`vectors` are dynamic in size and are stored on the heap while `arrays` have fixed size and are stored in the stack

```plaintext
    A trait is like a contract that outlines certain rules, these rules are defined as methods
    when a type opts to honor a traits's requirements i.e the rules we say the type implements these traits
    Types can vary in their implementation but still implement the same trait

    In simple terms trait is an interface for a type.
```

`dbg!()` => file path + line + number of spaces in the line + the entire result in detail

The range type is not available in the top level of file and is nested in a `module`

## What is ownership ?

Ownership is a set of rules compiler checks for to ensure program will be free of memory errors

## NOTE : the string literal &str is not stored either on stack or on heap rather it is embedded in the binary executable generated by the compiler

Associated functions are called on types and methods are called on instance of the type. Generally Associated functions do not have the `&self` passed as an argument.

When a `String` is created on heap correspondingly on the stack there will be an entry that will created which holds the reference to the String on heap,its length and capacity(amount of bytes available in the heap location).

`println!()` macro takes an immutable reference to argument passed.

`drop()` function can be called manually too.

rust has a feature called auto dereference

rust also implements the `Display` trait for references hence when you print a reference it will print the value and not the address.

An attribute is a directive to the compiler It is metadata on the line above a construct that coustomizes how the compiler parses the code.

A mutable reference does not implement a copy trait
An Immutable reference implements a copy trait

`&String can be converted to &str while the converse is not true`

Composite types like arrays and tuples have ownership over their elements

if an value implements the Copy trait, Rust will create a copy of it when we index into the type.

If an value does not implement the Copy trait, ownership will move form the composite type to the new owner.

the slice index does not represent the position of the value in a string it rather gives the byte Value it just happens so that the byte value is the same as position value in English.

The length of the string slice refers to the count of its bytes and not of its characters

```rust
    impl<K> time<K> {
        // “I am implementing methods for time<K>, where K is a generic type, and I call that type K.”
    }
```

## The Rust Prelude
The rust prelude is a collection of named constructs that are available automatically in every program.


## Methods to remember
```rust
    // conditionals
    while let
    if let // Use when you wanna Match on single pattern, variable inside let is only valid in let scope.
    let else // variable inside the let will be available after let scope.

    unwrap // no default or error value will Panic
    unwrap.or(default value)
    expect(error message)

    is_err()
    is_ok()

    is_empty()
```

Vec::from(a)  // a is an array 

```rust

    fn pp(mut vec : Vec<i32>) {
        vec.push()
    }

    // mut here is for the variable and will not be applicabe to the type of data being passed in 


```